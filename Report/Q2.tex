\subsection{}
The \algo{BUILD} algorithm builds a rooted tree from a set of constraints on leaves if possible. The constraints used are of the form $(i,j)<(k,l)$. $(x,y)$ denotes the lowest common ancestor of $x$ and $y$ where we can assume $x \neq y$. $(i,j)<(k,l)$ denotes that $(i,j)$ is a proper descendant of $(k,l)$ i.e. $(i,j)$ is further from the root than $(k,l)$. A set of these constraints can be used to build a tree, however it is not always possible to build a tree from a set of constraints.

The \algo{BUILD} is a recursive algorithm where at every recursive step it aims to partition the current set of symbols (leaves) into subsets, which can then be  recused  into. Formalising this, given a set of symbols $T$ we want to partition $T$ into subsets $S_1, S_2, \cdot, S_r$ where $r \geq 2$. To create these subsets we observe two conditions that subsets must follow for a constraint $(i,j)<(k,l)$.
(1) $i$ and $j$ must be in the same set. Otherwise $(i, j)$ cannot be a proper descendant of $(k,l)$.
(2) Either $k$ and $l$ are in different sets (so $(k,l)$ is the root). Or $i,j,k,l$ are in the same set (so the constraint is dealt with in a future recursive call). If $k$ and $l$ are in the same set that isn't the same set as $i,j$ are in then $(i,j)$ and $(k,l)$ are siblings, hence not holding the constraint.

Given we partition symbols into subsets it seems natural that we also partition constraints so that recursive steps need not filter the constraints to find those that are applicable given the current set of symbols. There are 2 different cases arising from the possible partitioning of symbols.
(1) $k,l$ are in the same subset hence we have a subset $i,j,k,l$. This doesn't yet fulfill our constraint so the constraint needs to be included in the partition.
(2) $k,l$ are in different sets implying $(k,l)$ is the root and $(i,j)$ is a child. As we have satisfied the constraint, and no recursive step can invalidate the constraint, it does not need to be included in the partition. I.e. the constraint has been fulfilled and can be ignored in further recursive steps.

With this constraint partition scheme it becomes easy to see that if we are only able to partition the symbols into one set then we cannot create a tree. A recursive step will not eliminate any conditions nor create subsets of symbols hence will not aid in making a tree (as it is impossible), ultimately leading inductively to an infinite loop.

With these methods for partitioning symbols and constraint we have all the tools we need to define the \algo{BUILD} algorithm. The recursive \algo{BUILD} function will taken in as arguments a set of symbols and constraints. It will return a tree. As a base case \algo{BUILD} on a single symbol is returned as a single node tree. At every step we conduct the partition step which partitions the symbols, using the rules as described above. If we find the partition only creates one set of symbols then we know there is no tree that satisfies these constraints, hence that error can be propagated back through the recursion, for example by returning a null tree. We can eliminate and partition constraints using the partitioned symbols and rules as described above. If there is no error we can recurse into each subset pair of symbols and constraints. These recursive calls will return subtrees for each child. These child subtrees can be gathering under a new root node into a full tree which is then returned.    

\subsection{}
\begin{algorithm}[H]
    \SetAlgoLined
    \KwResult{ $\pi_C = S_1, S_2, \cdots, S_r$ }
     set $Q$ as empty queue\;
     set $\pi_C = \emptyset$\;
     %\tcc{iterate over all training examples}
     \For{integer i as index leaves l}{
        let $l$ be leaf $i$\;
        set $S[i]$ to set $\{l\}$\;
        add $S[i]$ to $\pi_C$\;
        set $setID[l] = i$\;
     }
     \For{integer i as index of each leaf l mentioned in a constraint}{
         set $L_i$ to an empty list\;
     }
     \For{each constraint $(i,j)<(k,l)$}{
        let c be the implication $k \equiv l \implies i \equiv l$\;
        add c to $L_{setID[k]}$\;
        add c to $L_{setID[l]}$\;
        add command $i \equiv j$ to $Q$\;
     }
     
     \While{$Q$ is not empty}{
        dequeue command $p \equiv q$ from $Q$\;
        let $S_p, S_q$ be $S[setID[p]]$ and $S[setID[p]]$ respectively\;
        \If{$S_p\neq S_q$}{
          let $L$ be the shorter of $L_{setID[p]}$ and $L_{setID[q]}$\;
          \For{ each implication $u \equiv v \implies x \equiv y$ in L}{ 
           \If{one of $u$ and v is in $S_p$ and the other is in $S_q$}{
               add command $x \equiv y$ to $Q$\;
           }
          }
          append $L_{setID[q]}$ to $L_{setID[p]}$\;
          update $setID[x]=setID[p]$ for all elements x in $S_q$\;
          merge $S_q$ into $S_p$\;
          remove $S_q$ from $\pi_c$\;
         }
       }
    
     \caption{Partition Step}
    \end{algorithm}

\pagebreak
\subsection{}

\input{Q2Tree}

\treeSplitPage{\begin{center}\textbf{Output}\end{center}}{\textbf{Input}}

\treeSplitPage{\treeStepA}{\stepArgs{a-n}{as in question}}

\treeSplitPage{\treeStepB}{\stepArgs{a,c,e,f,h,j,l,n}{
    \\
    $(c, h) < (a, n)$ 
    $(j, n) < (j, l)$
    $(c, a) < (f, h)$
    $(j, l) < (e, n)$
    $(n, l) < (a, f)$
    $(c, h) < (c, a)$ 
    $(e, f) < (h, l)$ 
    $(j, l) < (j, a)$ 
    $(j, n) < (j, f)$
}}

\treeSplitPage{\treeStepC}{\stepArgs{a,c,h}{\\$(c, h) < (c, a)$}}

\treeSplitPage{\treeStepD}{\stepArgs{c,h}{$\emptyset$}}

\treeSplitPage{\treeStepE}{\stepArgs{e,f}{$\emptyset$}}

\treeSplitPage{\treeStepF}{\stepArgs{j,n,l}{\\$(j, n) < (j, l)$}}

\treeSplitPage{\treeStepG}{\stepArgs{j, n}{$\emptyset$}}

\treeSplitPage{\treeStepH}{\stepArgs{b, d, g, i}{
    \\
    $(d, i) < (g, i)$
    $(g, b) < (g, i)$
}}

\treeSplitPage{\treeStepI}{\stepArgs{b, g}{$\emptyset$}}

\treeSplitPage{\treeStepJ}{\stepArgs{d, i}{$\emptyset$}}

\treeSplitPage{\treeStepK}{\stepArgs{k, m}{$\emptyset$}}


\subsubsection*{Final tree}
\finalTree

\subsection{}
\subsubsection*{}

$l^j_i$ denotes leaf $i$ in subtree $j$.
$n_j$ denotes number of leaves in subtree j.
$N$ denotes number of subtrees.
\Tree [. 
    \qroof{\textit{$l_1^1, l_2^1, \dots, l_{n_1}^1 $}}.
    \qroof{\textit{$l_1^2, l_2^2, \dots, l_{n_2}^2 $}}.
    \ldots.
    \qroof{\textit{$l_1^N, \ldots$}}.
]

construct $(l_1^k, l_1^{k+1}) < (l_1^k, *)$. Where $*$ represents a yet undecided leaf.


\begin{algorithm}[H]
    \LinesNumbered
    \SetAlgoLined
    \KwIn{tree $T$}
    \KwOut{ set of constraints $C$ }
     set $C=\emptyset$\;
     define leaves $l$ as previously described for tree $T$\;
     define $N$ as the number of subtrees of tree $T$\;
     \For{subtree $s$ of $T$}{
        let $c=$ \algo{REVERSE BUILD STEP}$(s)$\;
        update $c$ so any undecided leafs $*$ are replaced by leaf $x$ where $x \in T - s$\;
        update $C$ to contain $c$\label{alg:fProof}\;
     }
     
     let $a = \{(l_1^k, l_1^{k+1}) < (l_1^k, *)|k<N-1\}$\;
     update $C$ to contain $a$\;
    
     \Return{$C$}
     \caption{REVERSE BUILD STEP}
\end{algorithm}

\begin{algorithm}[H]
    \SetAlgoLined
    \KwIn{tree $T$}
    \KwOut{ set of constraints $C$ }
     
    let $C=$ \algo{REVERSE BUILD STEP}$(T)$\;
    update $C$ to remove any constrains containing undecided leaves $*$.
     
     \Return{$C$}
     \caption{REVERSE BUILD}
\end{algorithm}


Change this to prove that the set of incomplete constains can be used to departiton.
 The first part of the proof will prove that the set of constraints $c$ built on line \ref{alg:fProof} of \algo{REVERSE BUILD STEP} is sufficient to preform the following transformation which could be through of as the de-partitioning of $l$.

\textbf{From}
 \Tree [.
    [. 
        \qroof{\textit{$l_1^1, l_2^1, \dots, l_{n_1}^1 $}}.
        \ldots.
        \qroof{\textit{$l_1^N, \ldots$}}.
    ]
    \ldots.
    \qroof{\textit{$\subseteq T-l$}}.
    ]

\textbf{To}
\Tree [. 
    \qroof{\textit{$l = l_1^1, l_2^1, \dots, l_{n_N}^N $}}.
    \ldots.
    \qroof{\textit{$\subseteq T-l$}}.
]

Note $(i, j) < (k, l)$ means $k \equiv l \implies i \equiv l$ and $i \equiv j$

Let us redefine define the unknown leaf $*$ as $x$  $x\subset T-l$.
\algo{REVERSE BUILD STEP} creates constraints $(l_1^1, l_1^2) < (l_1^1, x)$, $(l_1^2, l_1^3) < (l_1^2, x)$, \ldots. It is clear to see that these constraints can only be satifed if a pair $l_1^k, l_1^{k+1}$ is a subtree of T. Next we will prove that all these paris are in the \textbf{same} subtree of T. Each pair have implications $l_1^1 \equiv l_1^2$, $l_1^2 \equiv l_1^3$, \ldots. Which can be simplified down to $l_1^1 \equiv l_1^2 \equiv l_1^3 \equiv \ldots$ which is equivelent to $l^1 \equiv l^2 \equiv l^3 \equiv \ldots$ where ommision of the intra subset index implies the whole subset. Hence we have proved all $l$ are in the same subset of the tree.


Next we will prove inductively, on the height of the input tree $T$, that the \algo{REVERSE BUILD STEP} will return a set of constraint that can be used to reconstruct an isomorphic copy of $T$ which we will call $R$. The recursive call that relates to a tree of height $k$ will recursive create a set of complete causes, used to describe that tree but also create incomplete clauses. These incomplete clauses are completed by and used by a tree of height $k+1$ to departition a tree of height $h$. Given that we want to prove facts about trees of height $h$ we can ignore incomplete clauses as they are only useful to a tree of $h+1$. To be explicit in the base case creating a tree of height $1$ incomplete clauses are only useful for trees of height $2$ and in an inductive case creating a tree of height $h+1$ incomplete clauses are only useful for tree of height $h+2$.


\textbf{Base case:} Tree $T$ of height 1 that contains a single root node and leaves $y_1, \ldots, y_n$. Running \algo{REVERSE BUILD STEP} on this tree then ignoring incomplete constraints will give us the empty set of constraints. The \algo{BUILD} will build tree $R=T$. 

\textbf{Inductive case:} Tree $T$ of height $h+1$. $T$ is made up of $N$ subtrees $s$. Inductively \algo{REVERSE BUILD STEP} on the subtrees return a contain returns a set of constrains used to build $s$ and a set of constrains with undecided leaves. From the proof of  line:\ref{alg:fProof} we know that the substituting in $x$ to the incomplete constraints from a subtree will ensure all the subtrees of $s$ share the same parent node i.e. create the unified set $l$. Doing this for all values of $s$ will introduce $N$ subtrees in $R$ where each subtree is $s$. Hence, $R=T$.  

\textbf{Inductive case:} Creating a tree $R$ that is isomorphic of tree $T$ that has height $h+1$. Tree $T$ contains $N$ subtrees $s_1, \ldots, s_N$. A recursive call on $s_i$ will return a set of clauses that can be used to construct $s_i$ and a also constraints that can be used to departition $s_i$. To departiton $s_i$ you need to substitue in an incomplete parameter which you xan do. Build will partition the departiton hence make the tree we want. Also it will create incomplete clauses that can be used to departition $T$


Proof plan:

each step creates a set of clauses with complete and incomplete clauses.
Complete describe the tree
Incomplete descibe the departitoning aka squshing of the tree.

Base case: root and leaves, 
empty complete -> builds tree
incomplete clauses -> describe departition

Inductive case:
tree $h+1$ contains lots of tree $h$. If you squish those trees build will unsqish and recurse into those trees which inductively builds tree $h$. And tree of trees iss what $h+1$ is.
incomplete clauses -> still describe departition.
